import java.util.concurrent.ConcurrentHashMap

description = "Apereo Central Authentication Service $version"
defaultTasks "clean", "build"

buildscript {
    repositories {

        mavenCentral()
        gradlePluginPortal()

        maven {
            url "https://repo.spring.io/milestone"
            mavenContent { releasesOnly() }
        }
        maven {
            url "https://repo.spring.io/snapshot"
            mavenContent { snapshotsOnly() }
        }

    }

    dependencies {
//        classpath "gradle.plugin.com.ewerk.gradle.plugins:jaxb2-plugin:1.0.10"
        classpath "com.github.node-gradle:gradle-node-plugin:$gradleNodeVersion"
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"
        classpath "com.gorylenko.gradle-git-properties:gradle-git-properties:$gradleGitVersion"
        classpath "io.freefair.gradle:lombok-plugin:$gradleLombokVersion"
        classpath "com.github.ben-manes:gradle-versions-plugin:$gradleDependencyVersionsVersion"
        classpath "org.graalvm.buildtools:native-gradle-plugin:${gradleGraalVmNativePluginVersion}"
        // classpath "net.ltgt.gradle:gradle-errorprone-plugin:$gradleErrorProneVersion"
        classpath "com.github.johnrengelman:shadow:$gradleShadowVersion"
        //classpath "io.github.gradle-nexus:publish-plugin:$gradleNexusPublishingVersion"
    }
}


ext {
    srcTagMap = new ConcurrentHashMap<File, Set<String>>()

    repositoryUsername = providers.systemProperty("repositoryUsername").getOrNull()
    repositoryPassword = providers.systemProperty("repositoryPassword").getOrNull()

    publishSnapshots = providers.systemProperty("publishSnapshots").present
    publishReleases = providers.systemProperty("publishReleases").present

    publishFlag = publishSnapshots || publishReleases

    publishMinimalArtifacts = providers.systemProperty("publishMinimalArtifacts").present

    skipBootifulArtifact = providers.systemProperty("skipBootifulArtifact").present
    skipErrorProneCompiler = providers.systemProperty("skipErrorProneCompiler").present

    skipArtifactSigning = providers.systemProperty("skipArtifactSigning").present
    terminateCompilerOnWarning = providers.systemProperty("terminateCompilerOnWarning").getOrElse("true") == "true"

    enableRemoteDebugging = providers.systemProperty("enableRemoteDebugging").present
    remoteDebuggingSuspend = providers.systemProperty("remoteDebuggingSuspend").getOrElse("false") == "true" ? "y" : "n"
    generateGitProperties = publishFlag || providers.systemProperty("generateGitProperties").present
    generateTimestamps = publishFlag || providers.systemProperty("generateTimestamps").present

    ci = System.getenv("CI") || providers.systemProperty("CI").present

    excludedFilesFromTestCoverage = [
            '**/docs/**',
            '**/org/springframework/**',
            '**/soap/generated/**',
            '**/com/duosecurity/**',
            '**/org/apereo/inspektr/**',
            '**/net/jradius/**',
            '**/com/yubico/**',
            '**/saml/sts/SamlToken**',
            '**/**ConfigurationMetadata**',
            '**/**NimbusOAuthJacksonModule**',
            '**/**Application**',
            '**/**Application$**',
            '**/**Exception$**',
            '**/**Properties**',
            '**/**Properties$**'
    ]
}




apply from: rootProject.file("gradle/dependencies.gradle")
//apply from: rootProject.file("gradle/dependencyUpdates.gradle")


allprojects {
    apply plugin: "idea"
    apply plugin: "eclipse"
    apply plugin: "java-library"


    if (gradle.startParameter.taskNames.any { task -> task.contains("publishToMavenLocal") }) {
        apply plugin: "maven-publish"
    }

    apply from: rootProject.file("gradle/tasks.gradle")
    def arch = System.getProperty("os.arch")
    if (arch == "aarch64") {
        System.setProperty("os.arch", "x86_64")
        arch = System.getProperty("os.arch")
        def name = System.getProperty("os.name")
        logger.info("The OS platform architecture for this Gradle build is reset to ${arch} for ${name}")
    }

  //  apply plugin: "com.gorylenko.gradle-git-properties"

    project.ext["forceBootifulArtifact"] = null

    afterEvaluate { project ->
        if (true) {
           /* gitProperties {
                customProperty 'project.group', project.group
                customProperty 'project.name', project.name
                customProperty 'project.version', project.version
                customProperty 'project.description', project.description
                extProperty = "gitProps"
                keys = ["git.branch", "git.build.time", "git.build.user.name",
                        "git.build.version", "git.commit.id", "git.remote.origin.url"]
            }*/
        }
    }

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(project.targetCompatibility)
        }
    }

    idea {
        module {
            downloadSources = false
            downloadJavadoc = false
            jdkName = project.targetCompatibility
            excludeDirs += file(".gradle")
            [".settings", "classes", "bin", "out", "docs", "dependency-cache", "libs",
             "reports", "resources", "test-results", "tmp"].each {
                excludeDirs += project.layout.buildDirectory.files(it)
            }
        }
    }

    if (projectRequiresLombok(project)) {
        apply plugin: "io.freefair.lombok"
        lombok {
            version = "$lombokVersion"
        }
    }


}

subprojects {
    apply plugin: "maven-publish"
    apply plugin: "signing"

    ext.libraries = rootProject.ext.libraries

    configurations {
        tests
        provided
    }

    apply from: rootProject.file("gradle/overrides.gradle")


    sourceSets {
        main {
            compileClasspath += configurations.provided
            runtimeClasspath += configurations.provided

            java {
                srcDirs = ["${projectDir}/src/main/java"]
            }
            resources {
                srcDirs = ["${projectDir}/src/main/resources"]
            }
        }
    }

    ext.buildJarFile = new File(project.layout.buildDirectory.getAsFile().get(), "libs/${project.name}-${project.version}.jar")
}


tasks.named('jar') {
    def projectName = project.name
    def projectGroup = project.group
    def projectVersion = project.version
    def projectSpecVersion = project.ext.has("gitProps") ? project.ext.gitProps['git.commit.id'] : 'N/A'
    manifest {
        attributes(
                "Automatic-Module-Name": project.name.replace("-", "."),
                "Implementation-Title": projectName,
                "Implementation-Vendor": projectGroup,
                "Created-By": projectGroup)
        attributes(
                "Specification-Version": projectSpecVersion,
                "Implementation-Version": projectVersion,
        )
        if(projectName.contains("starter")){
            attributes(
                    'Main-Class': 'org.apereo.cas.web.CasWebApplication'
            )
        }
    }
}

tasks.register('gradleHome') {
    description = "Display GRADLE_HOME environment variable"
    doFirst {
        ansi.green "\nexport GRADLE_HOME=" + gradle.gradleHomeDir
    }
}


tasks.register('casVersion') {
    description = "Display current CAS version"
    def casVersion = rootProject.version
    doLast {
        println casVersion
    }
}

tasks.register('tomcatVersion') {
    description = "Display current Apache Tomcat version"
    doLast {
        println "${tomcatVersion}"
    }
}

tasks.register('signingKey') {
    description = "Display CAS signing key id"
    doLast {
        println "Signing key: " + project.findProperty("signing.keyId")
    }
}

tasks.register('verifyRequiredJavaVersion') {
    def requiredVersion = JavaVersion.toVersion(project.targetCompatibility)
    if (!JavaVersion.current().isCompatibleWith(requiredVersion)) {
        throw new GradleException("Current Java version ${JavaVersion.current()} does not match required Java version ${requiredVersion}")
    }
}

tasks.register('publishProjectModules') {
    def outputFile = new File(project.layout.buildDirectory.getAsFile().get(), "modules.json")
    def results = []
    subprojects.each {
        def publishMetadata = it.hasProperty("publishMetadata") ? it.property("publishMetadata") : false
        if (publishMetadata) {
            def metadata = it.ext.projectMetadata
            if (!metadata.containsKey("title") || !metadata.containsKey("category")) {
                throw new GradleException("Missing required project metadata for ${it.name}")
            }
            if (!metadata.containsKey("selectable")) {
                metadata.put("selectable", true)
            }
            results += [
                    name       : it.name,
                    version    : it.version,
                    group      : it.group,
                    description: it.description,
                    details    : metadata
            ]
        }
    }
    doLast {
        outputFile.getParentFile().mkdirs()
        def json = groovy.json.JsonOutput.toJson(results)
        outputFile.write json
        println "Published project modules to ${outputFile}"
    }
}

boolean projectRequiresLombok(Project project) {
    return !["api", "core", "docs", "support", "webapp"].contains(project.name) && project.name != "cas-server-documentation"
}
