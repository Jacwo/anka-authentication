import java.util.concurrent.ConcurrentHashMap

description = "Apereo Central Authentication Service $version"
defaultTasks "clean", "build"

buildscript {
    repositories {

        mavenCentral()
        gradlePluginPortal()

        maven {
            url "https://repo.spring.io/milestone"
            mavenContent { releasesOnly() }
        }
        maven {
            url "https://repo.spring.io/snapshot"
            mavenContent { snapshotsOnly() }
        }

    }

    dependencies {
//        classpath "gradle.plugin.com.ewerk.gradle.plugins:jaxb2-plugin:1.0.10"
        classpath "com.github.node-gradle:gradle-node-plugin:$gradleNodeVersion"
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$springBootVersion"
        classpath "com.gorylenko.gradle-git-properties:gradle-git-properties:$gradleGitVersion"
        classpath "io.freefair.gradle:lombok-plugin:$gradleLombokVersion"
        classpath "com.github.ben-manes:gradle-versions-plugin:$gradleDependencyVersionsVersion"
        classpath "org.graalvm.buildtools:native-gradle-plugin:${gradleGraalVmNativePluginVersion}"
       // classpath "net.ltgt.gradle:gradle-errorprone-plugin:$gradleErrorProneVersion"
        classpath "com.github.johnrengelman:shadow:$gradleShadowVersion"
        classpath "io.github.gradle-nexus:publish-plugin:$gradleNexusPublishingVersion"
    }
}


ext {
    srcTagMap = new ConcurrentHashMap<File, Set<String>>()

    repositoryUsername = providers.systemProperty("repositoryUsername").getOrNull()
    repositoryPassword = providers.systemProperty("repositoryPassword").getOrNull()

    publishSnapshots = providers.systemProperty("publishSnapshots").present
    publishReleases = providers.systemProperty("publishReleases").present

    publishFlag = publishSnapshots || publishReleases

    publishMinimalArtifacts = providers.systemProperty("publishMinimalArtifacts").present

    skipBootifulArtifact = providers.systemProperty("skipBootifulArtifact").present
    skipErrorProneCompiler = providers.systemProperty("skipErrorProneCompiler").present

    skipArtifactSigning = providers.systemProperty("skipArtifactSigning").present
    terminateCompilerOnWarning = providers.systemProperty("terminateCompilerOnWarning").getOrElse("true") == "true"

    enableRemoteDebugging = providers.systemProperty("enableRemoteDebugging").present
    remoteDebuggingSuspend = providers.systemProperty("remoteDebuggingSuspend").getOrElse("false") == "true" ? "y" : "n"
    generateGitProperties = publishFlag || providers.systemProperty("generateGitProperties").present
    generateTimestamps = publishFlag || providers.systemProperty("generateTimestamps").present

    ci = System.getenv("CI") || providers.systemProperty("CI").present

    excludedFilesFromTestCoverage = [
            '**/docs/**',
            '**/org/springframework/**',
            '**/soap/generated/**',
            '**/com/duosecurity/**',
            '**/org/apereo/inspektr/**',
            '**/net/jradius/**',
            '**/com/yubico/**',
            '**/saml/sts/SamlToken**',
            '**/**ConfigurationMetadata**',
            '**/**NimbusOAuthJacksonModule**',
            '**/**Application**',
            '**/**Application$**',
            '**/**Exception$**',
            '**/**Properties**',
            '**/**Properties$**'
    ]
}

def isArtifactSigningRequired = {
    publishReleases && !skipArtifactSigning
}


apply from: rootProject.file("gradle/dependencies.gradle")
apply from: rootProject.file("gradle/dependencyUpdates.gradle")



allprojects {
    apply plugin: "idea"
    apply plugin: "eclipse"
    apply plugin: "java-library"


    if (gradle.startParameter.taskNames.any { task -> task.contains("publishToMavenLocal") }) {
        apply plugin: "maven-publish"
    }

    apply from: rootProject.file("gradle/tasks.gradle")
    def arch = System.getProperty("os.arch")
    if (arch == "aarch64") {
        System.setProperty("os.arch", "x86_64")
        arch = System.getProperty("os.arch")
        def name = System.getProperty("os.name")
        logger.info("The OS platform architecture for this Gradle build is reset to ${arch} for ${name}")
    }

    if (rootProject.generateGitProperties) {
        apply plugin: "com.gorylenko.gradle-git-properties"
    }

    project.ext["forceBootifulArtifact"] = null

    afterEvaluate { project ->
        if (rootProject.generateGitProperties) {
            gitProperties {
                customProperty 'project.group', project.group
                customProperty 'project.name', project.name
                customProperty 'project.version', project.version
                customProperty 'project.description', project.description
                extProperty = "gitProps"
                keys = ["git.branch", "git.build.time", "git.build.user.name",
                        "git.build.version", "git.commit.id", "git.remote.origin.url"]
            }
        }
    }

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(project.targetCompatibility)
        }
    }

    idea {
        module {
            downloadSources = false
            downloadJavadoc = false
            jdkName = project.targetCompatibility
            excludeDirs += file(".gradle")
            [".settings", "classes", "bin", "out", "docs", "dependency-cache", "libs",
             "reports", "resources", "test-results", "tmp"].each {
                excludeDirs += project.layout.buildDirectory.files(it)
            }
        }
    }

}

subprojects {
    if (projectShouldBePublished(project)) {
        apply plugin: "maven-publish"
        apply plugin: "signing"
    }

    /*if (!rootProject.skipErrorProneCompiler) {
        apply plugin: "net.ltgt.errorprone"
    }*/
    //apply from: rootProject.file("gradle/tests.gradle")

    ext.libraries = rootProject.ext.libraries

    configurations {
        tests
        provided
    }

    apply from: rootProject.file("gradle/overrides.gradle")

    /**
     * Apply publishing rules after the build has had a chance to
     * evaluate sub-projects to apply plugins, etc.
     */

    sourceSets {
        main {
            compileClasspath += configurations.provided
            runtimeClasspath += configurations.provided

            java {
                srcDirs = ["${projectDir}/src/main/java"]
            }
            resources {
                srcDirs = ["${projectDir}/src/main/resources"]
            }
        }
        test {
            java {
                srcDirs = ["${projectDir}/src/test/java"]
            }
            resources {
                srcDirs = ["${projectDir}/src/test/resources"]
            }
        }
    }

    ext.buildJarFile = new File(project.layout.buildDirectory.getAsFile().get(), "libs/${project.name}-${project.version}.jar")

    [compileTestJava, compileJava].each {
        it.inputs.property("github.repository") {
            System.getenv("GITHUB_REPOSITORY") ?: "apereo/cas"
        }

        if (rootProject.generateGitProperties) {
            it.dependsOn("generateGitProperties")
        }

        it.options.fork = true
        it.options.incremental = true

        def casCompilerArgs = ["-parameters"]
        if (rootProject.ext.terminateCompilerOnWarning) {
            casCompilerArgs.add("-Werror")
        }

/*        if (!rootProject.skipErrorProneCompiler) {
            it.options.errorprone.disableAllChecks = !rootProject.ext.terminateCompilerOnWarning
            it.options.errorprone.allErrorsAsWarnings = false
            it.options.errorprone.disableWarningsInGeneratedCode = true
            it.options.errorprone.excludedPaths = ".*com/duosecurity.*"
            it.options.errorprone.errorproneArgs = ['-Xep:StatementSwitchToExpressionSwitch:OFF',
                                                    '-Xep:ClassCanBeStatic:OFF',
                                                    '-Xep:NotJavadoc:OFF',
                                                    '-Xep:AddressSelection:OFF']
            casCompilerArgs.add("-XDcompilePolicy=byfile")
        }
        it.options.compilerArgs += casCompilerArgs*/
    }

    if (projectRequiresLombok(project)) {
        apply plugin: "io.freefair.lombok"
        lombok {
            version = "$lombokVersion"
        }
    }

    tasks.named('jar') {
        def projectName = project.name
        def projectGroup = project.group
        def projectVersion = project.version
        def projectSpecVersion = project.ext.has("gitProps") ? project.ext.gitProps['git.commit.id'] : 'N/A'
        manifest {
            attributes(
                    "Automatic-Module-Name": project.name.replace("-", "."),
                    "Implementation-Title": projectName,
                    "Implementation-Vendor": projectGroup,
                    "Created-By": projectGroup)
            if (generateTimestamps) {
                attributes("Implementation-Date": java.time.ZonedDateTime.now(java.time.ZoneOffset.UTC))
            }
            attributes(
                    "Specification-Version": projectSpecVersion,
                    "Implementation-Version": projectVersion)
        }
    }

    dependencies {

        implementation libraries.aspectj

        api libraries.swaggerannotations
        api libraries.slf4j
        api libraries.guava
        api libraries.commons
        api libraries.persondirectory
        api libraries.spring
        api libraries.jackson
        api libraries.httpclient
        api libraries.quartz
        api libraries.groovy
        api libraries.caffein
        api libraries.springcloud
        api libraries.springboot
        api libraries.springsecurity
        api libraries.springintegration
        api libraries.springwebflow
        api libraries.jakarta

        annotationProcessor libraries.springindexer
/*
        if (!providers.systemProperty("skipErrorProneCompiler").present) {
            errorprone "com.google.errorprone:error_prone_core:$errorProneVersion"
        }*/

        testImplementation libraries.tests
        testImplementation libraries.log4j
        testImplementation libraries.hibernatevalidator

        runtimeOnly libraries.httpclient4
    }
}

if (!gradle.startParameter.excludedTaskNames.contains("javadoc") || rootProject.publishFlag) {
    tasks.withType(Javadoc).configureEach {
        source subprojects.collect { project -> project.sourceSets.main.allJava }
        destinationDir = new File(project.layout.buildDirectory.getAsFile().get(), "javadoc")
        classpath = files(subprojects.collect { project -> project.sourceSets.main.compileClasspath })
        options.addBooleanOption('html5', true)
        failOnError = providers.systemProperty("ignoreJavadocFailures").present
    }

    tasks.register('aggregateJavadocsIntoJar', Jar) {
        dependsOn javadoc
        description = "Aggregate all Javadocs into a single directory"
        archiveClassifier.set("javadoc")
        from javadoc
    }
}

if (rootProject.publishFlag) {
    tasks.register('rootSourcesJar', Jar) {
        description = "Build JAR for the root CAS module"
        archiveBaseName.set("${project.archivesBaseName}")
        from rootProject.file("src")
    }
}

tasks.register('gradleHome') {
    description = "Display GRADLE_HOME environment variable"
    doFirst {
        ansi.green "\nexport GRADLE_HOME=" + gradle.gradleHomeDir
    }
}

if (rootProject.publishFlag && !rootProject.publishMinimalArtifacts) {
    artifacts {
        archives tasks.named('aggregateJavadocsIntoJar')
        archives tasks.named('rootSourcesJar')
    }
}

if (gradle.startParameter.taskNames.any { task -> task.startsWith("jacoco") }) {
    tasks.register('jacocoRootReport', JacocoReport) {
        outputs.cacheIf { true }

        subprojects.each {subproject -> {
            if (!subproject.path.contains(":docs")) {
                subproject.tasks.withType(Test).each{ task ->
                    dependsOn(task)
                    mustRunAfter(task)
                }
            }
        }}

        def executions = subprojects.collect {subproject ->
            def execFile = subproject.layout.buildDirectory.file('jacoco/jacocoTest.exec').get().asFile
            if (execFile.exists()) {
                logger.info "${subproject.name} with execution file ${execFile}"
                inputs.file(execFile).withPropertyName("${subproject.name}-jacoco").withPathSensitivity(PathSensitivity.RELATIVE)
            }
            execFile
        }

        logger.info "Coverage execution data files: ${executions}"
        executionData.from(executions)
        outputs.files(rootProject.layout.buildDirectory.file('reports/jacoco/jacocoRootReport/jacocoRootReport.xml').get().asFile)

        reports {
//            html.required.set(true)
            xml.required.set(true)
            csv.required.set(true)
        }
        additionalSourceDirs.setFrom(files(subprojects.sourceSets.main.allSource.srcDirs))
        sourceDirectories.setFrom(files(subprojects.sourceSets.main.allSource.srcDirs))
        classDirectories.setFrom(
                files(subprojects.sourceSets.main.output).collect {
                    fileTree(dir: it,
                            include: ['**/*.*'],
                            exclude: rootProject.excludedFilesFromTestCoverage
                    )
                })
    }
}

tasks.register('casVersion') {
    description = "Display current CAS version"
    def casVersion = rootProject.version
    doLast {
        println casVersion
    }
}

tasks.register('tomcatVersion') {
    description = "Display current Apache Tomcat version"
    doLast {
        println "${tomcatVersion}"
    }
}

tasks.register('signingKey') {
    description = "Display CAS signing key id"
    doLast {
        println "Signing key: " + project.findProperty("signing.keyId")
    }
}

tasks.register('verifyRequiredJavaVersion') {
    def requiredVersion = JavaVersion.toVersion(project.targetCompatibility)
    if (!JavaVersion.current().isCompatibleWith(requiredVersion)) {
        throw new GradleException("Current Java version ${JavaVersion.current()} does not match required Java version ${requiredVersion}")
    }
}

tasks.register('publishProjectModules') {
    def outputFile = new File(project.layout.buildDirectory.getAsFile().get(), "modules.json")
    def results = []
    subprojects.each {
        def publishMetadata = it.hasProperty("publishMetadata") ? it.property("publishMetadata") : false
        if (publishMetadata) {
            def metadata = it.ext.projectMetadata
            if (!metadata.containsKey("title") || !metadata.containsKey("category")) {
                throw new GradleException("Missing required project metadata for ${it.name}")
            }
            if (!metadata.containsKey("selectable")) {
                metadata.put("selectable", true)
            }
            results += [
                    name: it.name,
                    version: it.version,
                    group: it.group,
                    description: it.description,
                    details: metadata
            ]
        }
    }
    doLast {
        outputFile.getParentFile().mkdirs()
        def json = groovy.json.JsonOutput.toJson(results)
        outputFile.write json
        println "Published project modules to ${outputFile}"
    }
}

boolean projectShouldBePublished(Project project) {
    def publishable = !["api", "core", "docs", "support", "webapp"].contains(project.name)
            && !project.getPath().contains("cas-server-documentation")
    if ("${releaseRepositoryUrl}".contains("github.com") && project.getPath().contains("cas-server-support-shell")) {
        // shell is too big for github
        publishable = false
    }
    project.ext.publishable = publishable
}

boolean projectRequiresLombok(Project project) {
    return !["api", "core", "docs", "support", "webapp"].contains(project.name) && project.name != "cas-server-documentation"
}
